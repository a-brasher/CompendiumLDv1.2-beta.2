/********************************************************************************
 *                                                                              *
 *  (c) Copyright 2012 Verizon Communications USA and The Open University UK    *
 *                                                                              *
 *  This software is freely distributed in accordance with                      *
 *  the GNU Lesser General Public (LGPL) license, version 3 or later            *
 *  as published by the Free Software Foundation.                               *
 *  For details see LGPL: http://www.fsf.org/licensing/licenses/lgpl.html       *
 *               and GPL: http://www.fsf.org/licensing/licenses/gpl-3.0.html    *
 *                                                                              *
 *  This software is provided by the copyright holders and contributors "as is" *
 *  and any express or implied warranties, including, but not limited to, the   *
 *  implied warranties of merchantability and fitness for a particular purpose  *
 *  are disclaimed. In no event shall the copyright owner or contributors be    *
 *  liable for any direct, indirect, incidental, special, exemplary, or         *
 *  consequential damages (including, but not limited to, procurement of        *
 *  substitute goods or services; loss of use, data, or profits; or business    *
 *  interruption) however caused and on any theory of liability, whether in     *
 *  contract, strict liability, or tort (including negligence or otherwise)     *
 *  arising in any way out of the use of this software, even if advised of the  *
 *  possibility of such damage.                                                 *
 *                                                                              *
 ********************************************************************************/

package com.compendium.learningdesign.io.xml;

import java.awt.Dialog;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;

import java.io.IOException;
import java.io.InputStream;

import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Vector;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerFactoryConfigurationError;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.jdom2.Attribute;
import org.jdom2.DocType;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.Namespace;
import org.jdom2.input.DOMBuilder;
import org.jdom2.output.DOMOutputter;
import org.jdom2.output.Format;
import org.xml.sax.SAXException;

import com.compendium.ProjectCompendium;
import com.compendium.core.datamodel.Link;
import com.compendium.core.datamodel.NodePosition;
import com.compendium.core.datamodel.NodeSummary;
import com.compendium.core.datamodel.View;
import com.compendium.io.xml.XMLReader;
import com.compendium.learningdesign.io.svg.SvgExport;
import com.compendium.ui.UIListViewFrame;
import com.compendium.ui.UIViewFrame;

public class LdXMLGenerator extends LdXMLExport {
	/** String to store the XML generated by this class	**/
private String sXmlRepresentation = null;

/** The list of nodes to be pasted.	**/
private ArrayList<NodePosition> oNodePosnsToBePasted;

/** The list of links to be pasted.	**/
private ArrayList<Link> oLinksToBePasted = new ArrayList<Link>();


/**
 * This method adds the CompendiumLD xml namespace prefix to the Element oElement,
 * all its attributes, and all its children and their attributes.
 * 
 * @param oElement
 */
public static void cLdNamespaceQualify(Element oElement)	{
	Namespace oCLdNamespace = Namespace.getNamespace(SvgExport.sCldNsPf, SvgExport.sCldNsUri);
	//oCldXmlRoot.addNamespaceDeclaration(oNamespace);

	if (oElement.getNamespace() == Namespace.NO_NAMESPACE) {
		oElement = oElement.setNamespace(oCLdNamespace);
	}
	List<Attribute> oAttributes = oElement.getAttributes();
	Iterator<Attribute> oAtIterator = oAttributes.iterator();
	while (oAtIterator.hasNext()) {
		Attribute oAtt = oAtIterator.next();
		if (oAtt.getNamespace() == Namespace.NO_NAMESPACE) {
			oAtt = oAtt.setNamespace(oCLdNamespace);
		}
	}

	List<Element> childElements = oElement.getChildren();
	Iterator<Element> iterator = childElements.iterator();
	while (iterator.hasNext()) {
		Element child = iterator.next();
		cLdNamespaceQualify(child);
	}
}
	/**
	 * Constructs a LdXMLGenerator to generate an XML representation of the 
	 * View oView, to a depth determined by the parameter allDepths, and 
	 * for selected nodes or all nodes determined by the parameter 
	 * selectedOnly.	  
	 * @param oView - the root View to be exported
	 * @param allDepths - if true, the XML file generated will include all depths of Views.
	 * @param selectedOnly - if true, only selected nodes will be included in the XML file generated.
	 */
	public LdXMLGenerator(View oView,  boolean allDepths,
			boolean selectedOnly) {
		
		super(oView, "", allDepths, selectedOnly, false);
	
		Format oFormat = Format.getPrettyFormat();
		oFormat.setEncoding("UTF16");
		oXMLOutputter.setFormat(oFormat);
	}
	
	public LdXMLGenerator(UIViewFrame frame,  boolean allDepths,
			boolean selectedOnly) {
		
		super(frame, "",  allDepths,  selectedOnly, false, false, false, false);
		Format oFormat = Format.getPrettyFormat();
		oFormat.setEncoding("UTF16");
		oXMLOutputter.setFormat(oFormat);
	}
	
	/**
	 * Constructs a LdXMLGenerator to generate an XML representation of the 
	 * View oView, to a depth determined by the parameter allDepths, and 
	 * for selected nodes or all nodes determined by the parameter 
	 * selectedOnly.
	 * 
	 * @param oInputView - the View that the  nodes and links are being copied from
	 * @param oNodePosnsForPasting - a list of nodes that will be copied from
	 *  oInputView into the XML file generated 
	 * @param oLinksForPasting - - a list of links that will be copied from oInputView
	 *  into the XML file generated
	 * @param bALlDepths - if true, the XML file generated will include all depths of Views below oInputView.
	 * @param bSelectedNodesOnly - if true, only selected nodes will be included in the XML file generated.
	 */
	public LdXMLGenerator(View oInputView, ArrayList<NodePosition> oNodePosnsForPasting, ArrayList<Link> oLinksForPasting,
				boolean bALlDepths, boolean bSelectedNodesOnly) {
		this(oInputView,  bALlDepths, bSelectedNodesOnly);
		oNodePosnsToBePasted = oNodePosnsForPasting;
		oLinksToBePasted = oLinksForPasting;
	}

	/**
	 * This is the main run method and it Start the export thread, and begins the convertion to XML.
	 *
	 * @see #convertToXML
	 * @see #onCompletion
	 */
	public void run() {
		oThread = new ProgressThread("Map Copy Progress..", "Copy completed", Dialog.ModalityType.MODELESS);
		oThread.start();

		convertToXML();
		onCompletion();
		bExportComplete = true;
		oProgressDialog.dispose();
	}

	/**
	 * Convert Compendium node/s into xml output.
	 * This is an implementation of the convertToXML() method from the XMLExport class
	 * uusing the jdom library.
	 */
	public  void convertToXML() {
		/** Note even though the root view being exported may not be an LdActivityView,
		 *  still have to export all as if they were in case views within views are 
		 *  LdActivity views	**/ 
		 
		StringBuffer root = new StringBuffer(1000); // This variable can be deleted once conversion to jdom is complete
		// The jdom xml document to be created
		Document doc = new Document();  // Not used yet
		//Need to change DTD reference to compendiumld.dtd at a URL
		DocType xmlDocType = new DocType("model", "CompendiumLD.dtd"); // Not used yet
		ProjectCompendium.APP.setWaitCursor();
		Element rootElem = new Element("model");  // Not used yet		
		
		root.append("<?xml version=\"1.0\" encoding=\"UTF-16\"?>\n");

		//root.append("<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n");
		root.append("<!DOCTYPE model SYSTEM \"CompendiumLD.dtd\">\n");

		root.append("<model ");

		htNodesCheck.clear();
		htCodesCheck.clear();
		htLinksCheck.clear();
		htMeetings.clear();
		vtNodes.removeAllElements();
		vtCodes.removeAllElements();
		vtLinks.removeAllElements();
		
		try {
			if (this.getCurrentView() != null) {
				doc.setDocType(xmlDocType); //Not used yet
				rootElem.setAttribute("rootview", oCurrentView.getId()); //Not used yet
				doc.setRootElement(rootElem); //Not used yet
				root.append( "rootview=\""+oCurrentView.getId()+"\">\n");
				// PROCESS SELECTED NODES AND LINKS ONLY
				if (bSelectedOnly) {
					processSelectedNodesForExport();
				}
				else {	// PROCESS ALL NODES AND LINKS
					int count = 0;

					if (!bAllDepths)
						count = oCurrentView.getNumberOfNodes();
					else {
						nCount += 2;
						oProgressBar.setValue(nCount);
						oProgressDialog.setStatus(nCount);
						count = countDepth(oCurrentView);
					}

			  		oProgressBar.setMaximum(count+12);

					processNodeForExport(oCurrentView, oCurrentView.getParentNode());
				}
			}
		}
		catch(Exception ex) {
			ex.printStackTrace();
			ProjectCompendium.APP.displayError("Exception: (XMLExport.convertToXML) " + ex.getMessage());
			oProgressDialog.setVisible(false);
			oProgressDialog.dispose();
			ProjectCompendium.APP.setStatus("");
			bHasFailed = true;
			return;
		}

		if (bXMLExportCancelled || checkProgress()) {
			root = null;
			bHasFailed = true;
			return;
		}
		nCount += 3;
		oProgressBar.setValue(nCount);
		oProgressDialog.setStatus(nCount);

		root.append( processDataToXML() );
		/** For when jdom is used for output of all node and view data
		String sXmlDoc = oXMLOutputter.outputString(doc);
		String sXMLDocContents = processDataToXML();
		sXmlDoc += sXMLDocContents;
		root = new StringBuffer(sXmlDoc);
		**/
		if (bXMLExportCancelled || checkProgress()) {
			root = null;
			bHasFailed = true;
			return;
		}
		nCount +=3;
		oProgressBar.setValue(nCount);
		oProgressDialog.setStatus(nCount);

		root.append("</model>");
	
		sXmlRepresentation = root.toString();
		
		oProgressDialog.setVisible(false);
		//oProgressDialog.dispose();
		ProjectCompendium.APP.setStatus("");
		
	}
	
	/**
	 * Process the currently selected nodes for export.
	 */
	protected void processSelectedNodesForExport() {
		int count = 0;
		
		ArrayList<NodePosition>  oNodePositions = null;
		ArrayList<NodePosition>  nodesForCount = null;
		ArrayList<Link>  links = null;
		int numberOfNodes = 0;
//If the input view is a map
		if (!View.isListType(this.oCurrentView.getType())) {
			//oUIViewPane = ((UIMapViewFrame)oUIViewFrame).getViewPane();

			oNodePositions = oNodePosnsToBePasted;
			nodesForCount = oNodePosnsToBePasted;

			links = oLinksToBePasted ;

			numberOfNodes = oNodePosnsToBePasted.size();
		}
		else {
			//The handling of list still has not been worked out.
			oUIList = ((UIListViewFrame)oUIViewFrame).getUIList();
			oNodePositions = oNodePosnsToBePasted;
			nodesForCount = oNodePosnsToBePasted;
			numberOfNodes = oNodePosnsToBePasted.size();
		}

		// GET COUNT FOR PROGRESS BAR
		if (!bAllDepths)
			count += numberOfNodes;
		else {
			count += numberOfNodes;
			for(ListIterator<NodePosition> oIt = nodesForCount.listIterator(); oIt.hasNext();) {
				NodeSummary node = null;
				node = oIt.next().getNode();

				if (View.isViewType(node.getType())) {
						htCheckDepth.put(node.getId(), node);
					count += countDepth((View) node);
				}
			}
		}
		oProgressBar.setMaximum(count+12);

		// IF THIS IS A MAP PROCESS LINKS
		if (links != null)	{
			processLinks( links, oCurrentView );
		}
		processNodeSummary(oCurrentView);

		String sViewID = "";
		ListIterator<NodePosition> oIt =  oNodePositions.listIterator();
		while (oIt.hasNext())	{
			NodePosition nodePos = null;
			
			nodePos = oIt.next();

			NodeSummary node = nodePos.getNode();
			
			View nodeView = nodePos.getView();
			Date creationDate = nodePos.getCreationDate();
			long creationDateSecs = creationDate.getTime();

			Date modificationDate = nodePos.getModificationDate();
			long modificationDateSecs = modificationDate.getTime();

			Vector viewData = new Vector(18);
			sViewID = oCurrentView.getId();
			viewData.add((Object) sViewID);
			viewData.add((Object) node.getId());
			viewData.add((Object) new Integer(nodePos.getXPos()));
			viewData.add((Object) new Integer(nodePos.getYPos()));
			viewData.add((Object) new Long(creationDateSecs) );
			viewData.add((Object) new Long(modificationDateSecs) );			

			viewData.add((Object) new Boolean(nodePos.getShowTags()));
			viewData.add((Object) new Boolean(nodePos.getShowText()) );
			viewData.add((Object) new Boolean(nodePos.getShowTrans()) );
			viewData.add((Object) new Boolean(nodePos.getShowWeight()) );
			viewData.add((Object) new Boolean(nodePos.getShowSmallIcon()) );
			viewData.add((Object) new Boolean(nodePos.getHideIcon()) );		
			viewData.add((Object) new Integer(nodePos.getLabelWrapWidth()) );
			viewData.add((Object) new Integer(nodePos.getFontSize()) );
			viewData.add((Object) nodePos.getFontFace());
			viewData.add((Object) new Integer(nodePos.getFontStyle()) );
			viewData.add((Object) new Integer(nodePos.getForeground()) );
			viewData.add((Object) new Integer(nodePos.getBackground()) );
			
			vtViews.add((Object) viewData);
			htViewsCheck.put(sViewID, sViewID);

			processNodeForExport(node, oCurrentView);
		}
	}

	
	/**
	 *	Returns a W3C DOM version of the root node of the xml tree representation
	 *	of the CompendiumLD data for this instance, qualified with the CompendiumLD 
	 *	namespace prefix "cld". 
	 * @return org.w3c.dom.Element "model" and all its children.
	 */
	public org.w3c.dom.Element generateXmlWithNameSpace()	{
		String sNsDoc = "";
		org.w3c.dom.Document oTempDoc = null;
		org.w3c.dom.Element oCldRoot = null;
		String sTemp = this.getXmlRepresentation();
		if (sTemp.length() < 2)
			return oCldRoot;
		
		XMLReader reader = new XMLReader();
		DOMOutputter oDOMOutputter = new DOMOutputter(); 
		try {
			oTempDoc = reader.readText(sTemp, true);
			Document oDoc = this.createJDomDocument(oTempDoc);
			
			Element oCldJDRoot = oDoc.getRootElement();
			LdXMLGenerator.cLdNamespaceQualify(oCldJDRoot);
			sNsDoc = oCldJDRoot.toString();
			oCldRoot = oDOMOutputter .output(oCldJDRoot);
		} catch (Exception oEx) {
			System.out.println("Error generaing XML: " + oEx.getMessage());
		}
		return oCldRoot;
	}

	
	/**
	 * Creates a JDom version of the supplied W3C DOM  document (ensuring that it is namespace aware).
	 * @param oDoc
	 * @return
	 */
	public Document createJDomDocument( org.w3c.dom.Document oDoc)	{
		DOMSource oSource = new DOMSource(oDoc);
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		StreamResult outputTarget = new StreamResult(outputStream);
		Document oJDOMDoc = null;
		try {
			TransformerFactory.newInstance().newTransformer().transform(oSource, outputTarget);
		} catch (TransformerConfigurationException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (TransformerException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (TransformerFactoryConfigurationError e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		InputStream is = new ByteArrayInputStream(outputStream.toByteArray());
		 DocumentBuilderFactory domfactory = DocumentBuilderFactory.newInstance(); 
		 domfactory.setNamespaceAware(true);
		 org.w3c.dom.Document oTempDoc = null;
		 try {
			DocumentBuilder dombuilder = domfactory.newDocumentBuilder();
			oTempDoc = dombuilder.parse(is);
		} catch (ParserConfigurationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (SAXException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		DOMBuilder oDOMBuilder = new DOMBuilder();
		oJDOMDoc = oDOMBuilder.build(oTempDoc);
		return oJDOMDoc;
	}
	/**
	 * @return the sXmlRepresentation
	 */
	public String getXmlRepresentation() {
		return sXmlRepresentation;
	}
}
